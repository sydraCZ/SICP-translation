教师，指挥官，营养师，心理学家，和家长们program。军队，学生，和社会群体们programed。对大的问题进行的攻关需要一系列programs，其中大多数是从过程中闪现的。这些programs充斥着的issues，呈现出特别针对手头前问题的样子。真的要把programing本身视为、欣赏为智力活动，你必须转向计算机编程；你必须读和写计算机程序--很多的程序。无论是这个程序值几钱，还是这个程序伺服着哪个应用都不要紧。重要的是，在创建更多程序时，它们与其他程序的配合得好不好以及顺畅程度如何。程序员必须同时追求局部的完美和集体的适当。在这本书里，“program”这个词的使用聚焦于创造，执行，和学习，用Lisp的一种方言写的，在电脑上执行的程序。使用Lisp，我们不是为了限制我们编什么，而只是约定好我们的表述记号。
我们这本书议题上的交流，引导我们到三个现象聚焦点：人的意识，程序集，以及电脑。每个电脑程序都是一个model，孵化于人的意识中，关于现实的或精神的步骤过程。这些（起于人类经验、思考的）processes，数量上及其庞大，细节上错综复杂难以理解，且每一时一刻都只能部分地理解。用程序很少能把它们建模成我们永久满意的样子。因此，虽然我们的程序是仔细精巧打造的，抽象符号的集合，铁索连环的功能函数的马赛克拼图，但它们仍不断演化：我们改变它们，当我们对model的理解加深、扩大、泛化直至我们到达一个接近稳固的地方（这时，其他model仍然让我们挣扎）。The source of the exhilaration associated with computer programming is the continual unfolding 1.within the mind and 2.on the computer of mechanisms (expressed as programs) and 3.the explosion of perception (they generate).编程的兴奋源泉，是持续展开，在脑中，在（表达成程序的机制结构的）计算机中，在（它们产生的）观念认知爆炸中。如果艺术阐释我们的梦，那么计算机在程序的外壳下实行它们！
就所有它的力量来说，计算机是一个严厉的工头。它的程序必须正确无误，我们想表达的必须在每一个细节上精确表达。和其他有符号参与的活动一样，我们在论证中说服自己相信程序的正确性。Lisp自身可以被委派一个语义（btw另一个模型），且如果程序的功能可以被具体指定描述specified（比如，谓词演算），那么，逻辑上的证明方法可以被用于产生一个合适的正确性论证。不幸的是，随着程序变大变复杂（总是这样），这种具体指定描述specifications的适用性、统一性、正确性变得值得怀疑，由此，完全形式化论证complete formal arguments 极少陪伴在大程序的身边。随着大程序从小变大，很重要的一点是我们开发出了一个标准程序结构（我们已经确定过它是对的，通常叫它idioms惯式）的武器库，并且学着（用已证的组织化技术）把它们联合成一个大结构。这些技术在本书被充分对待，对它们的理解，乃是参与编程--这种普罗米修斯事业--的要义或者说本质。对组织化技术的揭露和掌握，无出其右地，将快速提升我们创造大型的、有意义的程序的能力。反过来说，编写大型程序十分劳神费力（这个情况）也刺激我们去发明新的方法用以减小（我们要把功能和细节加进大程序时产生的）混乱。
不同于程序，电脑必须遵守物理定律。如果它们希望跑得快--几纳秒一次状态切换--它们就要在很小距离传递电子（至多1.5feet）。大量的设备元件（空间密集的）产生的热量，需要排走。精良的工程艺术被开发出来用以平衡功能的丰富度和元件密度。任何情况下，硬件运行的层次总是比我们关心程序的层次更原始。把我们的Lisp程序 转成“机器”程序的步骤过程
processes也是我们编的抽象模型model。对它们的研究和创造给出了a great deal of insight into the organizational programs associated with programming arbitrary models一大堆针对编写任意模型的有组织程序的洞见。当然电脑本身就是这样模型化modeled的一个东西。想一想：最小物理开关元素是量子力学模型化的modeled by，量子力学是被微分方程描述的，微分方程的细节行为被一大堆近似值捕捉，近似值是用电脑程序表现的，程序运行在电脑，电脑组成是……！
分别定义三个方面不仅仅是战术上的方便。不过，如他们所说，这些全是在头脑里的东西，这种逻辑区分导致了在这三个焦点之间符号交流的加速，这些焦点的丰富、生动、潜力在（只靠生命自己进化的）人类经验方面占尽优势。it’s all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. 最好，三个方面的关系是亚稳定的。电脑从未大到快到足够。每一个硬件技术上的突破带领来了更巨大的程序企业，新的组织原则，和丰富的抽象模型。每一个读者都应该是不是问问自己“到哪才是头？”--但是不要问太频繁免得你，因为苦乐参半的态度的限制，错过了编程的乐趣。
在我们写的程序中间，一些（但不足够）表示了精确的数学函数，比如对一串数字排序或找最大值，确定是否素数性质，或求平方根。我们把这些程序叫做算法，关于它们的最优化行为我们知道很多，特别是有关两个重要参数--执行时间和存储要求。程序员应该追求好的算法和惯用法。虽然有些程序天然抗拒精确详述，但这依然是程序员的责任，去估计，并永远试图去提高，程序的性能 。
Lisp是幸存者，历经了四分之一个世纪的使用。动态语言中，只有Fortran拥有更长的历史。 两者都助力了在应用上的重要领域的编程需求，Fortran助力了科学、工程计算，Lisp支持了人工智能。 两个领域一直保持着重要性，并且它们的程序员如此不懈努力在两门语言上，以至于两门语言应该会在至少下一个四分之一世纪里保持活跃使用。
Lisp一直在变。这本书使用的Scheme方言已经从原始Lisp语进化了，和后来的在很多重要方向上不同了，包括变量绑定的静态域 和允许函数如同返回变量那样返回函数。 including static scoping for variable binding and permitting functions to yield functions as values. 在语义结构上Scheme近似于Algol 60的程度不逊于早期Lisp。 In its semantic structure Scheme is as closely akin to Algol 60 as to early Lisps. Algol 60--不可能再有活跃的一门语言--存在于Scheme和Pascal语言的年代。Algol 60, never to be an active language again, lives on in the genes of Scheme and Pascal. 很难找出两门语言的比它们更不同了。It would be difficult to find two languages that are the communicating coin of two more different cultures than those gathered around these two languages.Pascal是为了建造金字塔--壮丽、令人屏息的固定结构，由一大团推动巨石就位建造的。 Pascal is for building pyramids—imposing, breathtaking,

static structures built by armies pushing heavy blocks into place.而Lisp是为了构造有机体壮丽的，令人屏息的动态结构，由一小片一小片合适且变动不定的大量简单有机体组成。 Lisp is for building organisms—imposing, breath- taking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. The orga- nizing principles used are the same in both cases, except for one extraordinarily important difference: The discre- tionary exportable functionality entrusted to the individ- ual Lisp programmer is more than an order of magnitude greater than that to be found within Pascal enterprises. Lisp programs inflate libraries with functions whose utility transcends the application that produced them. The list, Lisp’s native data structure, is largely responsible for such growth of utility. The simple structure and natural applica- bility of lists are reflected in functions that are amazingly nonidiosyncratic. In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. As a re- sult the pyramid must stand unchanged for a millennium; the organism must evolve or perish.
To illustrate this difference, compare the treatment of material and exercises within this book with that in any first-course text using Pascal. Do not labor under the il- lusion that this is a text digestible at MIT only, peculiar to the breed found there. It is precisely what a serious book

on programming Lisp must be, no matter who the student is or where it is used.
Note that this is a text about programming, unlike most Lisp books, which are used as a preparation for work in artificial intelligence. After all, the critical programming concerns of software engineering and artificial intelligence tend to coalesce as the systems under investigation be- come larger. This explains why there is such growing in- terest in Lisp outside of artificial intelligence.
As one would expect from its goals, artificial intelligence research generates many significant programming prob- lems. In other programming cultures this spate of prob- lems spawns new languages. Indeed, in any very large pro- gramming task a useful organizing principle is to control and isolate traffic within the task modules via the inven- tion of language. These languages tend to become less primitive as one approaches the boundaries of the system where we humans interact most often. As a result, such systems contain complex language-processing functions replicated many times. Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. Finally, it is this very simplicity of syn- tax and semantics that is responsible for the burden and freedom borne by all Lisp programmers. No Lisp program

of any size beyond a few lines can be written without be- ing saturated with discretionary functions. Invent and fit; have fits and reinvent! We toast the Lisp programmer who pens his thoughts within nests of parentheses.
Alan J. Perlis
New Haven, Connecticut

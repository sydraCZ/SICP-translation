	教师，指挥官，营养师，心理学家，和家长们program。军队，学生，和社会群体们programed。对大的问题进行的攻关需要一系列programs，其中大多数是从过程中闪现的。这些programs充斥着的issues，呈现出特别针对手头前问题的样子。真的要把programing本身视为、欣赏为智力活动，你必须转向计算机编程；你必须读和写计算机程序--很多的程序。无论是这个程序值几钱，还是这个程序伺服着哪个应用都不要紧。重要的是，在创建更多程序时，它们与其他程序的配合得好不好以及顺畅程度如何。程序员必须同时追求局部的完美和集体的适当。在这本书里，“program”这个词的使用聚焦于创造，执行，和学习，用Lisp的一种方言写的，在电脑上执行的程序。使用Lisp，我们不是为了限制我们编什么，而只是约定好我们的表述记号。
	我们这本书议题上的交流，引导我们到三个现象聚焦点：人的意识，程序集，以及电脑。每个电脑程序都是一个model，孵化于人的意识中，关于现实的或精神的步骤过程。这些（起于人类经验、思考的）processes，数量上及其庞大，细节上错综复杂难以理解，且每一时一刻都只能部分地理解。用程序很少能把它们建模成我们永久满意的样子。因此，虽然我们的程序是仔细精巧打造的，抽象符号的集合，铁索连环的功能函数的马赛克拼图，但它们仍不断演化：我们改变它们，当我们对model的理解加深、扩大、泛化直至我们到达一个接近稳固的地方（这时，其他model仍然让我们挣扎）。【The source of the exhilaration associated with computer programming is the continual unfolding 1.within the mind and 2.on the computer of mechanisms (expressed as programs) and 3.the explosion of perception (they generate).】和编程有关的的兴奋源泉是持续开展源源不断的，存在于头脑中，在（表达成程序的机制结构的）计算机中，在（它们产生的）观念认知爆炸中。如果艺术阐释我们的梦，那么计算机在程序的外壳下实行它们！
	就所有它的力量来说，计算机是一个严厉的工头。它的程序必须正确无误，我们想表达的必须在每一个细节上精确表达。和其他有符号参与的活动一样，我们在论证中说服自己相信程序的正确性。Lisp自身可以被委派一个语义（btw另一个模型），且如果程序的功能可以被具体指定描述specified（比如，谓词演算），那么，逻辑上的证明方法可以被用于产生一个合适的正确性论证。不幸的是，随着程序变大变复杂（总是这样），这种具体指定描述specifications的适用性、统一性、正确性变得值得怀疑，由此，完全形式化论证complete formal arguments 极少陪伴在大程序的身边。随着大程序从小变大，很重要的一点是我们开发出了一个标准程序结构（我们已经确定过它是对的，通常叫它idioms惯式）的武器库，并且学着（用已证的组织化技术）把它们联合成一个大结构。这些技术在本书被充分对待，对它们的理解，乃是参与编程--这种普罗米修斯事业--的要义或者说本质。对组织化技术的揭露和掌握，无出其右地，将快速提升我们创造大型的、有意义的程序的能力。反过来说，编写大型程序十分劳神费力（这个情况）也刺激我们去发明新的方法用以减小（我们要把功能和细节加进大程序时产生的）混乱。
	不同于程序，电脑必须遵守物理定律。如果它们希望跑得快--几纳秒一次状态切换--它们就要在很小距离传递电子（至多1.5feet）。大量的设备元件（空间密集的）产生的热量，需要排走。精良的工程艺术被开发出来用以平衡功能的丰富度和元件密度。任何情况下，硬件运行的层次总是比我们关心程序的层次更原始。把我们的Lisp程序 转成“机器”程序的步骤过程processes也是我们编的抽象模型model。对它们的研究和创造给出了【a great deal of insight into the organizational programs associated with programming arbitrary models】一大堆针对编写任意模型的有组织程序的洞见。当然电脑本身就是这样模型化modeled的一个东西。想一想：最小物理开关元素是量子力学模型化的【modeled by】，量子力学是被微分方程描述的，微分方程的细节行为被一大堆近似值捕捉，近似值是用电脑程序表现的，程序运行在电脑，电脑组成是……！
	分别定义三个方面不仅仅是战术上的方便。不过，如他们所说，这些全是在头脑里的东西，这种逻辑区分导致了在这三个焦点之间符号交流的加速，这些焦点的丰富、生动、潜力在（只靠生命自己进化的）人类经验方面占尽优势。it’s all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. 最好，三个方面的关系是亚稳定的。电脑从未大到快到足够。每一个硬件技术上的突破带领来了更巨大的程序企业，新的组织原则，和丰富的抽象模型。每一个读者都应该是不是问问自己“到哪才是头？”--但是不要问太频繁免得你，因为苦乐参半的态度的限制，错过了编程的乐趣。
	在我们写的程序中间，一些（但不足够）表示了精确的数学函数，比如对一串数字排序或找最大值，确定是否素数性质，或求平方根。我们把这些程序叫做算法，许算法因最优化的性能表现被大家所知晓，特别是有关两个重要参数--执行时间和存储要求。程序员应该追求好的算法和惯用法。虽然有些程序天然抗拒精确详述，但这依然是程序员的责任，去估计，并永远试图去提高，程序的性能 。
Lisp是幸存者，历经了四分之一个世纪的使用。动态语言中，只有Fortran拥有更长的历史。 两者都助力了在应用上的重要领域的编程需求，Fortran助力了科学、工程计算，Lisp支持了人工智能。 两个领域一直保持着重要性，并且它们的程序员如此不懈努力在两门语言上，以至于两门语言应该会在至少下一个四分之一世纪里保持活跃使用。
	Lisp一直在变。这本书使用的Scheme方言已经从原始Lisp语进化了，和后来的在很多重要方向上不同了，包括变量绑定的静态域 和允许函数如同返回变量那样返回函数。 【……including static scoping for variable binding and permitting functions to yield functions as values.】 在语义结构上Scheme类似于Algol 60的程度近乎于早期Lisp。【 In its semantic structure Scheme is as closely akin to Algol 60 as to early Lisps.】 Algol 60--不可能再成为活跃的语言了--存在于Scheme和Pascal语言的基因里。【Algol 60, never to be an active language again, lives on in the genes of Scheme and Pascal.】 很难找出两门作为（比其他聚集在它们两者周围的语言还要更风格迥异的）两个文化之间的communicating coin的语言了。【It would be difficult to find two languages that are the communicating coin of two more different cultures than those gathered around these two languages.】Pascal的用处是为了建造金字塔～（有着）壮丽、令人屏息的静态结构，由大军团通过推动巨石就位（pushing sth. into palce）建造。 【Pascal is for building pyramids—imposing, breathtaking,static structures built by armies pushing heavy blocks into place.】而Lisp的用处是为了构造有机体～（有着）壮丽的，令人屏息的动态结构，由小分队（通过把起伏不定的无数的简单有机体们安置就位（fitting sth. into place））建成。【 Lisp is for building organisms—imposing, breathtaking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. 】两者用到的组织原则都是一样的，除了一个异常重要的差异：在托付给Lisp独立开发者的 自由决定的输出性功能，比起从Pascal规划里发现的，大了不止一个数量级。【The discretionary exportable functionality entrusted to the individual Lisp programmer / is more than an order of magnitude greater than / that to be found within Pascal enterprises.】lisp程序用以扩充函数库的这些函数，在效用上远超产生它们的那些应用。对函数库这样的扩充，列表list（Lisp的天然固有数据结构）是很大的原因。列表简单的结构和天然的实用性反映在了那些惊人普适【nonidiosyncratic】的函数上。在Pascal中过多声明数据结构的情况 导致了 专门化，限制和禁止了函数之间的临时协同。 【In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. 】有100个函数操作在1个数据结构上好过有10个函数操作10个数据结构。因此金字塔要屹立一千年；而有机体要么进化要么腐烂。
	为了形象表现这个区别，可以拿材料的论述和本书的练习题，同Pascal入门书比较。不要费力想象“这是只有在MIT才需要读的书”。准确的说，无论哪里的学生、在哪里用，这都是一本关于Lisp编程的严肃的书该有的样子。
	注意这是一本编程书，不同于大部分作为AI前置课程的Lisp书籍。总之，在研究工作越来越大的情况下，关于软件工程领域的的批判性编程技术和AI技术趋于联合成系统工程【tend to coalesce as the systems】。这解释了为什么在AI领域外有这么多对于Lisp的兴趣。
	正如对AI的目标应有的期望那样，AI研究催生了许多有意义的编程难题。在其他编程文化中，这一波难题孵化了新语言。确实，在任何巨大的程序任务中，一个有用的组织原则是，通过语言的发明来控制和隔离任务模块间的交流。这些语言趋于变得不那么基础（primitive），当它们接近我们人类通常和系统交互的边缘的地方。因此，这样的系统包括了多次重复的复杂的语言处理函数。Lisp有着如此简单的语法和语义，从而使解析工作可以非常基本而简单。由此解析工作的技术含量基本可以忽略，也很少阻碍到大型Lisp系统的成长和变化速度。最后，语法语义非常简单，简单到成为对所有Lisp程序员一种重负和自由的负担。任何规模的Lisp程序（除了几行那种），无不充盈着各式各样的函数。发明和修改，修正完再发明！我们举杯，向Lisp程序员写在层层括号里的思考结晶致意。
  Alan J. Perlis
New Haven, Connecticut


1.构建带过程步骤的抽象

	心智作用于简单概念之上的活动，主要在三个方面：1.组合若干的简单概念成为一个复合概念，如此一来就能产生全部的复杂概念。2.取来两个概念，不管是简单还是复杂的，放在一起观察对照，而不将两者合二为一，如此一来就能产生所有属于“关系”的概念。3.把一个概念，从现实世界在它周围的其他具体概念中，分离出来：此所谓抽象，如此一来普遍性的概念就能全部产生了。
--约翰洛克 《关于“人类的领悟”随笔》1690

	我们即将学习一个概念“计算进程”computational process。计算进程是存在于计算机内的一种抽象存在。随着演变，“进程”操作着“数据”，另一种抽象物。进程的演化是由一系列规则所指挥的，这些规则叫做“程序”。人们创造程序去指挥进程。效果上看，等于我们用咒语召唤出计算机的灵魂。
	计算进程的确挺像巫师口中关于灵魂的概念。它看不见摸不着。它根本不是一堆物质。然而它却非常真实。它可以完成智力上的工作。它可以回答问题。可以在银行兑付钱款、操作工厂里的机械臂来影响到这个世界。我们所用来召唤进程的程序就像巫师的咒语。神秘深奥的编程语言中的符号表达式，规定着我们想让进程执行的任务，咒语由这些符号表达式小心地组合而成。
	一个计算进程，在正确运转的计算机中，确切精准的执行着程序。这样，就像巫师的徒弟，新手程序猿必须学会理解和预计他们咒语的后果。甚至程序里的小小的错误（通常叫做bug或者glitch故障）都能导致复杂和难以预料的后果。
	幸运的事，学编程没有学巫术那么危险，因为我们所要处理的灵魂被以安全的方式方便的保管着。不过，真实世界的编程就需要细心，专业，和智慧了。例如，在计算机辅助系统里的一个小小的bug，就可能导致飞机或水坝的灾难性事故、或者工业机器人的自毁。
	软件工程大师有能力组织好程序，所以他们合理地确定作为结果的程序能执行既定的任务。他们预先想象了他们的系统的行为。他们知道怎么构造程序，以使意料之外的问题不会导致灾难性的后果，并且当问题确实出现时，他们能调试程序。良好设计下的计算系统，就像良好设计的摩托车或核反应堆，是在模块化的规则下设计的，以使局部可以分别的被构建，替代，和调试。

	在Lisp下编程

	我们需要一个合适的语言去表述进程，为了这个目的我们将使用编程语言Lisp。就像我们每天的想法通常用的是我们的自然语言（如英法日语），而量化的现象用的是数学标记，我们的步骤过程化的（procedural）想法将用Lisp表述。Lisp在1950年代发明，作为一种形式标记法，用以对特定逻辑表达式（称为递归方程）的用法做推理，递归方程为计算当作模型。这个语言有约翰麦卡锡构想出来，给予他的论文“符号表达式的递归函数及其机械计算”（1960）。
	除了它当做数学形式标记法的创立，Lisp也是一门实用的语言。Lisp解释器是一个执行Lisp表示的进程的机器。第一个Lisp解释器由MC在（来自“Artificial Intelligence Group of the MIT Research Laboratory of Electronics and in the MIT Computation Center.”【注释1】的）同事和学生的帮助下实现。Lisp，名字来自缩写，是被设计成，为攻克如代数表达式的符号微分、积分这样的难题，提供符号操作能力的。为此它包括了一些新的数据对象如原子atom和列表list，显著地和同时期的语言区分开来。
	Lisp不是协商一致设计的努力成果。代之的是，在一种试验性的规则下，在对用户的需要的响应和对实用性的考量中，不断进化。Lisp非正式的演化持续多年，Lisp用户协会传统上限制了宣布任何官方的语言定义的企图。这种演化，陪伴着初始构想的灵活性和优雅，使得Lisp这门第二老的当世仍在用的语言，能够继续调整以包容大部分的现代编程设计想法。这样，Lisp如今就是一个方言家族，虽然共享大部分的特性，但以显著的方式互相区分。本书方言是Scheme。【注释2】
	因为它的试验性和对符号操作的强调，Lisp一开始对数值计算非常低效，至少比起Fortran是这样。不过多年过后，Lisp已经开发了将程序翻译成机器码的编译器，可以相当高效的执行数值计算。对于特殊的应用，Lisp用起来已经非常高效了【注释3】。虽然Lisp仍未克服它的让人绝望的低效的名声，但Lisp现在用在了很多不以效率为中心的应用上。比如，Lisp已成为了操作系统shell语言的选择语言，和编辑器和电脑辅助设计系统的选择语言。
	如果Lisp不是主流语言，为什么我们用它作为我们编程讨论课的框架？因为它拥有很多独特的特性，使它成为杰出的媒介，来学习重要的的编程构造和数据结构，来联结它们和支持他们的语言特性。其中最显著的特性就是Lisp对进程process（称作步骤procedure）的表述，自身可以当做Lisp数据来表示和操作。这一点的重要性在于，有些强大的程序设计技术依赖于这种“模糊被动的数据和主动的进程”的能力，正如我们应该发现的，Lisp的操作进程一如数据的灵活性，使之成为现存最便于探索这些技术的语言。操作进程一如数据的能力也令Lisp成为需要处理“其他语言的程序”作为数据（比如支持机器码的解释器、编译器）时的一种杰出的的语言。即使越过这些考虑，在Lisp下变成也是非常有趣的。
	

	

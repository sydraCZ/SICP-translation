1.1 编程的元素

一个强大的编程语言不仅仅是一个指挥电脑执行任务的工具。它也会提供让我们组织过程想法的框架。如此，当我们描述一个语言时，我们要特别注意这个语言提供的将简单认识组合成复杂认识的方法。每一个强大的语言都有三个实现这一点的机制：
	> 基础表达式 用以表示这个语言关注的最简单的实体
	> 组合的方法 用以从较简单的元素构造出复杂的元素
	> 抽象的方法 用以将复杂元素视为整体进行命名和操作
编程中，我们处理两种元素：步骤过程procedures和数据data。（之后我们会发现两者并不是泾渭分明。）通俗的说，数据是我们操作的“东西”，而“步骤过程”是关于操作数据的规则的描述。如此，任何强大的编程语言就有能力组合和抽象步骤过程和数据了。

在这个章节我们只处理简单的数值数据，以使我们能聚焦于步骤构建的规则「注释4」。在后面的章节，我们将看到，同样的规则也允许我们构建处理复合数据的步骤。

1.1.1 表达式

开启编程的一个简单方法，是使用Scheme解释器检验一些典型的交互。想象你坐在电脑终端前。你键入表达式，作为回应，解释器显示出它对表达式计算后的结果。
你可能键入的一种的基础表达式是数值。（更一般的，你键入的表达式包含的数值是10进位的。）如果你给Lisp一个数值
486
解释器将回应显示
486
描述数值的表达式可能包含基础运算步骤（比如+或*），并组合成复合表达式，以表示把这些步骤应用到这些数值。比如：
(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7

这样的表达式叫组合式combinations，用括号把列表表达式括起来的形式，表示应用步骤过程。最左边的元素是操作符operator，其他的叫做操作对象operands，组合式的值是“operator指代的步骤过程”应用在“operands表示的值”上获得的。
operands放在最左边的惯例被熟识为“前缀标记法”，它多少可能在一开始让人迷惑，因为它和通常的写数学式子的惯例差太多了。不过前缀标记法有不少优点，其中一个就是它能步骤容纳任意数量的参数，例如以下：
(+ 21 35 12 7)
75

(* 25 4 12)
1200

没有歧义，因为operator总是在最左边并且整个组合式都被括号限定范围了。
第二个优点是它提供了直观的方式让组合式可以呈网状nested，就是，可以让组合式的元素自己也是组合式。
(+(* 3 4)(- 10 6))
（原则上）没有限制网、表达式的整体复杂度的深度，Lisp解释器都可以计算。我们人类面对下面这样并不复杂的表达式可能会糊涂：
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
解释器可以马上求出 57。 显然我们为了帮自己看清楚可以这么写：
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
这个形式叫格式美化 pretty-printing，每个长组合式都被写成operands垂直排列。形成的凹缩进清晰地显示了表达式的结构【注释6】。
甚至是复杂表达式，解释器也总是以同样基本的规则来操作：它从终端读取表达式，对它求值，然后打印结果。这个操作模型常被说成解释器运行在“读-求值-打印 循环”read-eval-print loop=repl。显然，不需要明确指示解释器打印结果。

1.1.2 给环境命名
编程语言的一个紧要的方面是它对计算对象的命名方法。我们说名字确定了一个“值value就是对应的对象”的变量variable。
在Scheme，我们用“define”命名事物。键入
(define size 2)
让解释器将2关联上了名字“size”。【注释8】一旦名字size关联了数字2，我们可以通过名字引用数值2：
size
2
(* 5 size)
10
这里是define更进一步的例子：
(define pi 3.14159)

(define radius 10)

(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))

circumference
62.8318

“define”是我们语言里最简单的抽象，它让我们可以用简单的命名来引用复合操作的结果，如上面的circumference。一般，计算对象可能有非常复杂的结构，每次要用到时记住和重复它们的细节非常不方便。确实，复杂的程序是一步步构造复杂性不断增长的计算对象组建起来的。解释器使这样一步步的程序建造非常方便，因为在后续的交互中“名-实”关联name-object associations可以被增量地创造。这一特性鼓励了程序的递增开发及测试，同时极大地导致了如下事实，即Lisp程序通常由大量的关联简单程序构成。（裘版有误，因果相反）
应该清楚的是“取值-符号的关联和后续回收“的可能性意味着，解释器必须保持有一定的存储，用以保持对“名-实对”name-object pairs的追踪。这个存储叫做“环境”（更确切一点是“全局环境”，鉴于我们后面将看到的计算可能涉及多个环境）。

1.1.3 计算组合式（对组合式求值）

在本章节我们的目标之一是，独立出一个主题，过程步骤式思考。比如让我们考虑这个案例，在对组合式的求值中，解释器自身依循如下过程步骤。
	为对一个组合式求值，操作如下：
	> 对次级表达式求值。
	> 把 最左边的次级表达式代表的过程步骤（operator）应用到 其他的次级表达式的值代表的参数（operands）上。

即便如此简单的规则也在一般意义上形象地表示了进程的重要性。首先，我们观察到第一步强制规定了，为了完成组合式的求值，我们必须先履行针对组合式内每一个元素的求值进程。如此，求值规则天然的就是递归的；就是说，在它以内的步骤中，包括了执行自己这条规则的需要。

请注意，在深层网状组合式的例子中，递归的想法是多么的简洁，如果不这样递归的话，进程会多复杂。例如，计算
(* (+ 2 (* 4 6)) (+ 3 5 7))
要求求值规则应用到四个不同的组合式。我们可以用树形表示组合式来获取这个进程的图像，如图1.1 。每一个组合式表示为树枝上的一个节点，对应于它的opertor和operands。叶子节点（没有生出树枝的店）代表了操作符或者数字。用树的形式观察求值计算，可以想象operands的值被向上过滤，始于叶子节点，然后一层一层向上组合。一般来说，我们应该意识到递归对于处理等级的，树状的对象是非常强大的。事实上，求值规则的“向上过滤值”的形式，是一种一般性的进程“树累积”的一个样例。

接下来观察到，对第一步的反复应用带我们到了需要计算 并非组合式、而是基本表达式（如符号、内置操作、或其他名字） 的地点。我们对基本操作符的处理约定如下
	> 数字的值就是字面上的数字
	> 内置操作符的值是实行对应操作的机器指令序列
	> 其他名字的值是环境下这些名字所关联的实体

我们可以把第二条规则视为第三条的特例，只需要约定好诸如+和*这些在全局环境中的、及和它们的值代表的机器指令序列关联的符号。需要注意的关键点是，在决定表达式的符号的意义时，环境扮演的角色。在交互式语言如Lisp中，不指定环境的充分信息而说出一个表达式的值是没有意义的，比如表达式是(+ x 1)，而环境中没有说明x，甚至+。就像我们将在第三章叨叨的，环境的通用标记和表达式文本一样，在理解程序执行中都将扮演重要角色。
记住，上面求值规则没有搞定“定义”definitons。比如，对（define x 3）没有把define应用到两个参数x和3上，因为define的目的确切地说是关联x和3 。（就是说（define x 3）不是组合式。）

求值规则中像这样的例外我们叫它“特殊形式”。define是目前看到的唯一的例子，但马上就看得到其他的了。每一种特殊形式都有自己的求值规则。各种表达式（每个都带着关联的求值规则）组成了编程语言的语法。对比其他语言，Lisp有着非常简单的语法；那就是，表达式的求值规则可以用一个简单的通用规则和少量“特殊形式”特别指定的若干规则描述。

1.1.4 组合过程步骤





第二版序言
	有没有可能软件和其他东西不一样，它注定要被丢弃：关键是要始终把它看作一个肥皂泡？
	—Alan J. Perlis
	这本书的材料基于1980年开始的MIT入门级别的CS课程。当第一版出版时，我们已经教授这门课四年了，又过了二十多年后，这本第二版才问世。我们很高兴看到我们的工作被广为接受并被合并收录到其他文本里。我们已经看到我们的学生吸收了本书中的概念和程序，并应用到了新的操作系统及语言的核心中。从字面理解古老的塔木德经，我们的学生已经成了我们的建造者。我们很幸运能有这样能干的学生、这样有成就的建造者。
	在这一版的准备工作中，我们收录了来自自己的教学经验、同事评论等等方面建议的上百条的澄清说明。我们重新设计了书中大部分的主要程序系统，包括通用计算系统、解释器interpreters、寄存器机器模拟器register-machine simulator、编译器compiler；我们重写了所有程序例子以保证任何遵守IEEE Scheme标准（IEEE1990）的Scheme实现都能运行这些代码。
	这一版强调了几个新主题。其中最重要的是中心角色played by different approaches to dealing with time in computational mod- els:带状态的对象，并发编程、函数式编程、惰性求值、非确定性编程。我们为并发和非确定性加了几个章节，也尝试在全书中集成这些主题。
	第一版书很贴近我们MIT一学期的教学大纲。第二版有了所有这些新章节，就不可能在一学期都讲到了，所以本书教师将不得不做出挑选。在我们的教学中，我们有时跳过逻辑编程（4.4节），我们让学生是有寄存器机器模拟器但不讲它的实现（5.2节），还有我们只泛泛讲一下编译器（5.5节）。虽然如此，这节课还是很刺激。一个教员kennel希望覆盖前三或前四章，其他的放到后续课程里。
	
	The World-Wide-Web site http://mitpress.mit.edu /sicp provides support for users of this book. This includes programs from the book, sample programming assignments, supplementary materials, and downloadable implementations of the Scheme dialect of Lisp.

第一版序言
	计算机像小提琴。想想初学者试了一个音符就把琴丢一旁了。过后他就说，太难听了。这就是我们听到的人本主义者和大多计算机科学家之间的理论。她们说，对某些目的来讲，编程很赞，但是太不灵活了。小提琴和打字机也不灵活，除非你学会它。
	—Marvin Minsky, Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas

	“The Structure and Interpretation of Computer Programs”是MIT的CS的入门水平的课程。它对MIT在电子工程、CS、四分之一的通用核心全科中的学生是必修课，也包括电路和线性系统两个科目及数字系统设计一个科目。从1978年涉足这门课的开发，我们从1980年秋以这种形式教授这门课，每年面向600到700名学生。大多数学生几乎没有受过正式的计算机方面的训练，虽然很多也玩过计算机，还有一小部分有过广泛的编程过硬件设计经验。
	对这门CS引论课程的设计反映了两个主要关切。一，我们想构建这样的观点，计算机语言不仅仅是让计算机执行操作动作的途径，更是表达方法论观点的新式媒介。如此，程序就必须写得让人可读，附带的让机器去执行。二，我们相信这个层次的课程里，最精华的既不是特定语言结构的语法，也不是对特定函数的灵巧高效的算法，甚至不是算法的数学凡希和计算机基础，而是对发型软件系统的复杂度的控制。
	我们的目标是，完成这门课的学生能对 风格要素 和 编程美学 有良好的体悟。在控制大型系统的复杂度上，他们应该对主要的技术有把控力。我们应该有能力阅读50页长度的程序，如果程序风格是示范性的。我们应该知道不要读什么，什么时候不需要了解什么。他们应该能有把握地修改程序、保持原作精神和风格。
	这些技巧绝不是计算机编程独有的的。我们教授、提炼的技术在所有工程设计上是通用的。我们通过如下方法来控制复杂度：抽象模型、适当隐藏细节；建立约定接口，使我们能以“mix and match”的途径，用符合联合标准、好理解的零碎片段，去构建系统。我们还通过如下方法来控制复杂度：建立多种新的语言去表达我们的设计，其中每一种都着重强调设计上的特定方面并淡化其他。
	我们通向这门课的途径之下是我们的信念：计算机科学CS不是科学，且其重要性对计算机影响不大。计算机革命，是一种我们的思维方式、及我们思维的表达方式的一种革命。这种改变的精华，是一种（也许最好的名字是）“过程性认识论”的理论的浮现--对 从命令式的观点，而非经典数学持有的声明式的观点 派生出的知识结构的研究。数学通过“是什么”的符号提供了处理精确性的框架。计算机通过“怎么做”的符号提供了处理精确性的框架.
	在本材料的教学中我们使用一种程序语言的方言Lisp。我们从不正式的教这门语言，因为没必要。我们只是用它，学生也在几天之内学会用它。这是类Lisp的语言的一个巨大优势：它们只有非常少的方式去组合表达时，基本上没有语法结构。所有的形式化性质都可以在一小时内讲完，就好像国际象棋的规则一样。不久我们就忘了这门语言的语法细节（因为没有细节）然后开始来到正题--搞清我们到底计算什么，怎么把问题分解到可以处理的小块，怎么处理这些小块。Lisp另一大优势是它支持（但不是强制要用）更多的大规模的策略，在程序的模块单元分解上，比之于其他我所知的语言。我们可以对过程步骤合数据提取抽象模型，可以使用高阶函数去捕捉用法中的通用模式，可以使用参数和数据修改操作把模拟局部状态，可以用流和延迟求值去链接程序的一部分【we can link parts of a program with streams and delayed evaluation】，可以轻松实现嵌入式语言。所有这些都嵌入在交互环境里，带有对递增式程序设计、构造、测试、和debug的车色支持。感谢所有年代的Lisp魔术师，起始于John MaCarthy，塑造了这样优美的工具，有着史无前例的力量和优雅。
	Scheme，我们用的方言，是整合Lisp和Algol的力量和优雅的一个尝试。从 Lisp我们获得了源自简单语法的元语言学（metalinguistic）之力量，程序和数据对象的一致的表示法，带垃圾回收的 堆分配数据（garbage-collected heap-allocated data）。从Algol我们获得了词汇作用域（lexical scoping）和块结构，来自Algol协会的编程语言先驱的礼物。我们希望引用John Reynolds、Peter Landin对邱奇的lambda演算法同编程语言结构之间关系的洞见。我们也认识到，对那些在还没有计算机的糟糕年代里开拓探索的数学家们，我们需要感谢。这些先驱包括“Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.”

